/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 *
 *Create a module that can interface to the LEDs and button specifically for the
STM32F3 discovery board.
 *
 ******************************************************************************
 */

/**
 ******************************************************************************
 *
 ** LED CONTROL
 * Uses GPIOE pins 8 to 15 to control 8 LEDs.
 *
 * Initializes them to 0b00000001.
 *
 ** TIMER-BASED BLINKING
 * Sets up TIM2 to generate an interrupt every 1 second.
 * Toggles LEDs on and off every second → simple blinking effect.
 *
 ** BUTTON INTERRUPTS
 * Configures a rising-edge interrupt on PA0 (user button).
 * When the button is pressed, it triggers a callback (chase_led_callback).
 *
 ** CHASE EFFECT
 * Each button press shifts the active LED bit one place to the left.
 * The leftmost bit wraps around, creating a circular LED "chasing" pattern.

 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stddef.h>
#include "stm32f303xc.h"

// Not relevant here as no floating point math used but included in tut
#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

// global variable and callback pointer
static uint8_t led_state = 0;			// stores current LED output state (8 bits)
// The variable led_state is declared as static within the .c file, making it private to the file and inaccessible outside of the module. This ensures that the LED state is encapsulated and cannot be directly accessed or modified by other parts of the program.
// points to the button_callback function each time the button is pressed
void (*button_callback)() = NULL;		// function pointer to handle button press events

// Enable the clocks for desired peripherals (GPIOA, GPIOC, and GPIOE)
void enable_clocks() {
    RCC->AHBENR |= RCC_AHBENR_GPIOAEN;  // Enable clock for GPIOA (user button)
    RCC->AHBENR |= RCC_AHBENR_GPIOEEN;  // Enable clock for GPIOE (LEDs)
}

// initialise the discovery board I/O (just outputs: inputs are selected by default)
// void initialise_board() {
	// get a pointer to the second half word of the MODER register (for outputs pe8-15)
	// (GPIOE->MODER) controls the mode of each pin
	// uint16_t *led_output_registers = ((uint16_t *)&(GPIOE->MODER)) + 1; // ((uint16_t *)&(GPIOE->MODER)) + 1: GPIOE->MODER is a 32-bit register, pins PE0-PE15 spans bits 0-31, we want upper half (PE8-15) to be indexed at 1 ('active') as these correspond to LEDs
	// So, first part with int16 and GPIO3->MODER casts the 32 bit register into 16-bit halfwords (basically just separates it into two parts) so that the first is indexed as 0 (OFF) and second half controlling LEDs is 1. The '+1' points to the second halfword.
	//*led_output_registers = 0x5555; // 0x5555 as binary is 01010101 which sets each pin (pe8-15) to output mode (to light up LEDs)
//}

// From W05-C-Interrupt, sets up interrupt on rising edge of PA0 (user button) so that when button is pressed, interrupt is initiated
void enable_interrupt() {
	// Disable the interrupts while messing around with the settings
	//  otherwise can lead to strange behaviour
	__disable_irq();

	// Enable the system configuration controller (SYSCFG in RCC)
	RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;

	// External Interrupts details on large manual page 294)
	// PA0 is on interrupt EXTI0 large manual - page 250
	// EXTI0 in  SYSCFG_EXTICR1 needs to be 0x00 (SYSCFG_EXTICR1_EXTI0_PA)
	SYSCFG->EXTICR[0] = SYSCFG_EXTICR1_EXTI0_PA;

	//  Select EXTI0 interrupt on rising edge
	EXTI->RTSR |= EXTI_RTSR_TR0; // rising edge of EXTI line 0 (includes PA0)

	// set the interrupt from EXTI line 0 as 'not masked' - as in, enable it.
	EXTI->IMR |= EXTI_IMR_MR0;

	// Tell the NVIC module that EXTI0 interrupts should be handled
	NVIC_SetPriority(EXTI0_IRQn, 1);  // Set Priority
	NVIC_EnableIRQ(EXTI0_IRQn);

	// Re-enable all interrupts (now that we are finished)
	__enable_irq();
}

// Initialize the timer for LED speed control
// TIM2 for blinking
// The TIM2 interrupt is used to toggle the LEDs on a timed schedule, essentially making them "blink" or change pattern automatically in the background, without needing to wait/block in the main loop.
void init_timer() {
    RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;  	// Enable TIM2 clock
    TIM2->PSC = 4000;  						// Prescaler value (8 MHz / 8000 = 1 kHz)
    TIM2->ARR = 1000;  						// Auto-reload value for 1 Hz blinking
    TIM2->DIER |= TIM_DIER_UIE;  			// Enable update interrupt
    TIM2->CR1 |= TIM_CR1_CEN;  				// Start the timer
    NVIC_EnableIRQ(TIM2_IRQn);  			// Enable TIM2 interrupt in NVIC
    // Nested Vectored Interrupt Controller (NVIC) to enable the interrupt line for Timer 2 (TIM2).
    // Once enabled, if TIM2 triggers an interrupt (like a timer overflow), the corresponding interrupt handler (TIM2_IRQHandler()) will be called automatically by the CPU.
}

// Actual timer interrupt handler for controlling LED speed
void TIM2_IRQHandler(void) {
    if (TIM2->SR & TIM_SR_UIF) {  // Check update interrupt flag, TIM_SR_UIF is the "update interrupt flag" — it tells us the timer overflowed.
        TIM2->SR &= ~TIM_SR_UIF;  // Manually clear interrupt flag
        toggle_leds();			  // Change LED pattern
    }
}

// Returns the current LED state- allows other parts of the program to retrieve the LED state without directly accessing the led_state variable.
uint8_t get_led_state() {
    return led_state;
}

// Set the LED state with encapsulation
void set_led_state(uint8_t state) {
    led_state = state;
    uint8_t *led_register = ((uint8_t*)&(GPIOE->ODR)) + 1; // updates led_state and writes it to GPIOE output register (specifically bits 8–15, hence the offset).
    // To control LEDs, need to write to bits 8-15 of ODR (output data register)
    // Note that it is only uint8_t here (compared to uint16_t above) because each LED (PE8-15) uses only 1 bit in the ODR register compared to 2 in the MODER register.
    *led_register = state;
}


// Set the button press callback function, Allows registering a function to call when the button is pressed
// The function set_button_callback() allows the user to pass in a function pointer. This pointer is stored in the button_callback variable, so whenever the button is pressed, the corresponding function can be called.
void set_button_callback(void (*callback)()) { // *callback pointer
    button_callback = callback;
}

// Clears interrupt pending flag and runs the registered callback if it exists.
// Interrupt handler for button press (PA0)
// When the button (PA0) triggers an interrupt, the EXTI0_IRQHandler ISR is executed. Inside the ISR, the function pointer button_callback is checked, and if it is not NULL, the callback function is called. This triggers the function you passed during initialization.
void EXTI0_IRQHandler(void) {
    if (EXTI->PR & EXTI_PR_PR0) {  			// Check if the interrupt is pending for Pa0 (button)
        EXTI->PR |= EXTI_PR_PR0;  			// Clear interrupt flag
        if (button_callback != NULL) {
            button_callback();  			// Call the registered callback function
        }
    }
}

void initialise_digital_io() {
    // Configure PE8–PE15 as outputs (LEDs)
    uint16_t *led_output_registers = ((uint16_t *)&(GPIOE->MODER)) + 1;
    *led_output_registers = 0x5555;

    // Configure PA0 (button) as input
    GPIOA->MODER &= ~(0x3 << (0 * 2));
}

// LED toggle, button check, and wait functions
//Toggle: XOR current LED bits to toggle them.
// is_button_pressed: checks if PA0 is high.
// wait_for_button_press/release: blocking loops for button status.
// Toggle LEDs (PE8-15)
void toggle_leds() {
	 uint8_t *led_register = ((uint8_t*)&(GPIOE->ODR)) + 1;
	 *led_register ^= get_led_state();
}

// Check if button is pressed (PA0 == 1)
uint8_t is_button_pressed() {
    return (GPIOA->IDR & 0x01);
}

// Wait for button press (blocking)
void wait_for_button_press() {
    while (!is_button_pressed()) {};
}

// Wait for button release (blocking)
void wait_for_button_release() {
    while (is_button_pressed()) {};
}

// button callback for LED
// Rotates the LED pattern left.
// The MSB wraps around to LSB. Creates a "chasing" LED effect.
void chase_led_callback() {
    uint8_t state = get_led_state();
    state = (state << 1) | ((state & 0x80) >> 7);  // Rotate left by wrapping leftmost bit to rightmost position
    set_led_state(state);
}

int main(void) {
	// Initializes clocks, I/O, timer, and LED state.
	// Registers a callback to rotate LEDs when button is pressed.
	// Main loop is idle — interrupts handle everything.
    enable_clocks();
    initialise_digital_io();  // Make sure to initialize GPIOs
    init_timer();

    // Initialize LED state to a known pattern
    set_led_state(0b00000001);

    // Set the button callback to chase LEDs
    set_button_callback(chase_led_callback);
    enable_interrupt();

    while (1) {
        // Main loop can perform other tasks without blocking LED updates
    }
}
