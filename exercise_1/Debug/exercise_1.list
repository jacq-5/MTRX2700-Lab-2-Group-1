
exercise_1.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000194  08000000  08000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000003e0  08000194  08000194  00001194  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000000  08000574  0800057c  0000157c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  3 .ARM.extab    00000000  08000574  08000574  0000157c  2**0
                  CONTENTS
  4 .ARM          00000000  08000574  08000574  0000157c  2**0
                  CONTENTS
  5 .preinit_array 00000000  08000574  0800057c  0000157c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08000574  08000574  00001574  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .fini_array   00000004  08000578  08000578  00001578  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .data         00000000  20000000  20000000  0000157c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  9 .ccmram       00000000  10000000  10000000  0000157c  2**0
                  CONTENTS
 10 .bss          00000024  20000000  20000000  00002000  2**2
                  ALLOC
 11 ._user_heap_stack 00000604  20000024  20000024  00002000  2**0
                  ALLOC
 12 .ARM.attributes 00000030  00000000  00000000  0000157c  2**0
                  CONTENTS, READONLY
 13 .debug_info   00000c3c  00000000  00000000  000015ac  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_abbrev 000002c9  00000000  00000000  000021e8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_aranges 000000c8  00000000  00000000  000024b8  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_rnglists 0000008c  00000000  00000000  00002580  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_macro  00014e23  00000000  00000000  0000260c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_line   000007f2  00000000  00000000  0001742f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_str    00072a6c  00000000  00000000  00017c21  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .comment      00000043  00000000  00000000  0008a68d  2**0
                  CONTENTS, READONLY
 21 .debug_frame  00000270  00000000  00000000  0008a6d0  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_line_str 00000060  00000000  00000000  0008a940  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08000194 <__do_global_dtors_aux>:
 8000194:	b510      	push	{r4, lr}
 8000196:	4c05      	ldr	r4, [pc, #20]	@ (80001ac <__do_global_dtors_aux+0x18>)
 8000198:	7823      	ldrb	r3, [r4, #0]
 800019a:	b933      	cbnz	r3, 80001aa <__do_global_dtors_aux+0x16>
 800019c:	4b04      	ldr	r3, [pc, #16]	@ (80001b0 <__do_global_dtors_aux+0x1c>)
 800019e:	b113      	cbz	r3, 80001a6 <__do_global_dtors_aux+0x12>
 80001a0:	4804      	ldr	r0, [pc, #16]	@ (80001b4 <__do_global_dtors_aux+0x20>)
 80001a2:	f3af 8000 	nop.w
 80001a6:	2301      	movs	r3, #1
 80001a8:	7023      	strb	r3, [r4, #0]
 80001aa:	bd10      	pop	{r4, pc}
 80001ac:	20000000 	.word	0x20000000
 80001b0:	00000000 	.word	0x00000000
 80001b4:	0800055c 	.word	0x0800055c

080001b8 <frame_dummy>:
 80001b8:	b508      	push	{r3, lr}
 80001ba:	4b03      	ldr	r3, [pc, #12]	@ (80001c8 <frame_dummy+0x10>)
 80001bc:	b11b      	cbz	r3, 80001c6 <frame_dummy+0xe>
 80001be:	4903      	ldr	r1, [pc, #12]	@ (80001cc <frame_dummy+0x14>)
 80001c0:	4803      	ldr	r0, [pc, #12]	@ (80001d0 <frame_dummy+0x18>)
 80001c2:	f3af 8000 	nop.w
 80001c6:	bd08      	pop	{r3, pc}
 80001c8:	00000000 	.word	0x00000000
 80001cc:	20000004 	.word	0x20000004
 80001d0:	0800055c 	.word	0x0800055c

080001d4 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
 80001d4:	b480      	push	{r7}
 80001d6:	b083      	sub	sp, #12
 80001d8:	af00      	add	r7, sp, #0
 80001da:	4603      	mov	r3, r0
 80001dc:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 80001de:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80001e2:	2b00      	cmp	r3, #0
 80001e4:	db0b      	blt.n	80001fe <__NVIC_EnableIRQ+0x2a>
  {
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 80001e6:	79fb      	ldrb	r3, [r7, #7]
 80001e8:	f003 021f 	and.w	r2, r3, #31
 80001ec:	4907      	ldr	r1, [pc, #28]	@ (800020c <__NVIC_EnableIRQ+0x38>)
 80001ee:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80001f2:	095b      	lsrs	r3, r3, #5
 80001f4:	2001      	movs	r0, #1
 80001f6:	fa00 f202 	lsl.w	r2, r0, r2
 80001fa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
}
 80001fe:	bf00      	nop
 8000200:	370c      	adds	r7, #12
 8000202:	46bd      	mov	sp, r7
 8000204:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000208:	4770      	bx	lr
 800020a:	bf00      	nop
 800020c:	e000e100 	.word	0xe000e100

08000210 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8000210:	b480      	push	{r7}
 8000212:	b083      	sub	sp, #12
 8000214:	af00      	add	r7, sp, #0
 8000216:	4603      	mov	r3, r0
 8000218:	6039      	str	r1, [r7, #0]
 800021a:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 800021c:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8000220:	2b00      	cmp	r3, #0
 8000222:	db0a      	blt.n	800023a <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000224:	683b      	ldr	r3, [r7, #0]
 8000226:	b2da      	uxtb	r2, r3
 8000228:	490c      	ldr	r1, [pc, #48]	@ (800025c <__NVIC_SetPriority+0x4c>)
 800022a:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800022e:	0112      	lsls	r2, r2, #4
 8000230:	b2d2      	uxtb	r2, r2
 8000232:	440b      	add	r3, r1
 8000234:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 8000238:	e00a      	b.n	8000250 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800023a:	683b      	ldr	r3, [r7, #0]
 800023c:	b2da      	uxtb	r2, r3
 800023e:	4908      	ldr	r1, [pc, #32]	@ (8000260 <__NVIC_SetPriority+0x50>)
 8000240:	79fb      	ldrb	r3, [r7, #7]
 8000242:	f003 030f 	and.w	r3, r3, #15
 8000246:	3b04      	subs	r3, #4
 8000248:	0112      	lsls	r2, r2, #4
 800024a:	b2d2      	uxtb	r2, r2
 800024c:	440b      	add	r3, r1
 800024e:	761a      	strb	r2, [r3, #24]
}
 8000250:	bf00      	nop
 8000252:	370c      	adds	r7, #12
 8000254:	46bd      	mov	sp, r7
 8000256:	f85d 7b04 	ldr.w	r7, [sp], #4
 800025a:	4770      	bx	lr
 800025c:	e000e100 	.word	0xe000e100
 8000260:	e000ed00 	.word	0xe000ed00

08000264 <enable_clocks>:
// The variable led_state is declared as static within the .c file, making it private to the file and inaccessible outside of the module. This ensures that the LED state is encapsulated and cannot be directly accessed or modified by other parts of the program.
// points to the button_callback function each time the button is pressed
void (*button_callback)() = NULL;		// function pointer to handle button press events

// Enable the clocks for desired peripherals (GPIOA, GPIOC, and GPIOE)
void enable_clocks() {
 8000264:	b480      	push	{r7}
 8000266:	af00      	add	r7, sp, #0
    RCC->AHBENR |= RCC_AHBENR_GPIOAEN;  // Enable clock for GPIOA (user button)
 8000268:	4b08      	ldr	r3, [pc, #32]	@ (800028c <enable_clocks+0x28>)
 800026a:	695b      	ldr	r3, [r3, #20]
 800026c:	4a07      	ldr	r2, [pc, #28]	@ (800028c <enable_clocks+0x28>)
 800026e:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8000272:	6153      	str	r3, [r2, #20]
    RCC->AHBENR |= RCC_AHBENR_GPIOEEN;  // Enable clock for GPIOE (LEDs)
 8000274:	4b05      	ldr	r3, [pc, #20]	@ (800028c <enable_clocks+0x28>)
 8000276:	695b      	ldr	r3, [r3, #20]
 8000278:	4a04      	ldr	r2, [pc, #16]	@ (800028c <enable_clocks+0x28>)
 800027a:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 800027e:	6153      	str	r3, [r2, #20]
}
 8000280:	bf00      	nop
 8000282:	46bd      	mov	sp, r7
 8000284:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000288:	4770      	bx	lr
 800028a:	bf00      	nop
 800028c:	40021000 	.word	0x40021000

08000290 <enable_interrupt>:
	// So, first part with int16 and GPIO3->MODER casts the 32 bit register into 16-bit halfwords (basically just separates it into two parts) so that the first is indexed as 0 (OFF) and second half controlling LEDs is 1. The '+1' points to the second halfword.
	//*led_output_registers = 0x5555; // 0x5555 as binary is 01010101 which sets each pin (pe8-15) to output mode (to light up LEDs)
//}

// From W05-C-Interrupt, sets up interrupt on rising edge of PA0 (user button) so that when button is pressed, interrupt is initiated
void enable_interrupt() {
 8000290:	b580      	push	{r7, lr}
 8000292:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000294:	b672      	cpsid	i
}
 8000296:	bf00      	nop
	// Disable the interrupts while messing around with the settings
	//  otherwise can lead to strange behaviour
	__disable_irq();

	// Enable the system configuration controller (SYSCFG in RCC)
	RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
 8000298:	4b0f      	ldr	r3, [pc, #60]	@ (80002d8 <enable_interrupt+0x48>)
 800029a:	699b      	ldr	r3, [r3, #24]
 800029c:	4a0e      	ldr	r2, [pc, #56]	@ (80002d8 <enable_interrupt+0x48>)
 800029e:	f043 0301 	orr.w	r3, r3, #1
 80002a2:	6193      	str	r3, [r2, #24]

	// External Interrupts details on large manual page 294)
	// PA0 is on interrupt EXTI0 large manual - page 250
	// EXTI0 in  SYSCFG_EXTICR1 needs to be 0x00 (SYSCFG_EXTICR1_EXTI0_PA)
	SYSCFG->EXTICR[0] = SYSCFG_EXTICR1_EXTI0_PA;
 80002a4:	4b0d      	ldr	r3, [pc, #52]	@ (80002dc <enable_interrupt+0x4c>)
 80002a6:	2200      	movs	r2, #0
 80002a8:	609a      	str	r2, [r3, #8]

	//  Select EXTI0 interrupt on rising edge
	EXTI->RTSR |= EXTI_RTSR_TR0; // rising edge of EXTI line 0 (includes PA0)
 80002aa:	4b0d      	ldr	r3, [pc, #52]	@ (80002e0 <enable_interrupt+0x50>)
 80002ac:	689b      	ldr	r3, [r3, #8]
 80002ae:	4a0c      	ldr	r2, [pc, #48]	@ (80002e0 <enable_interrupt+0x50>)
 80002b0:	f043 0301 	orr.w	r3, r3, #1
 80002b4:	6093      	str	r3, [r2, #8]

	// set the interrupt from EXTI line 0 as 'not masked' - as in, enable it.
	EXTI->IMR |= EXTI_IMR_MR0;
 80002b6:	4b0a      	ldr	r3, [pc, #40]	@ (80002e0 <enable_interrupt+0x50>)
 80002b8:	681b      	ldr	r3, [r3, #0]
 80002ba:	4a09      	ldr	r2, [pc, #36]	@ (80002e0 <enable_interrupt+0x50>)
 80002bc:	f043 0301 	orr.w	r3, r3, #1
 80002c0:	6013      	str	r3, [r2, #0]

	// Tell the NVIC module that EXTI0 interrupts should be handled
	NVIC_SetPriority(EXTI0_IRQn, 1);  // Set Priority
 80002c2:	2101      	movs	r1, #1
 80002c4:	2006      	movs	r0, #6
 80002c6:	f7ff ffa3 	bl	8000210 <__NVIC_SetPriority>
	NVIC_EnableIRQ(EXTI0_IRQn);
 80002ca:	2006      	movs	r0, #6
 80002cc:	f7ff ff82 	bl	80001d4 <__NVIC_EnableIRQ>
  __ASM volatile ("cpsie i" : : : "memory");
 80002d0:	b662      	cpsie	i
}
 80002d2:	bf00      	nop

	// Re-enable all interrupts (now that we are finished)
	__enable_irq();
}
 80002d4:	bf00      	nop
 80002d6:	bd80      	pop	{r7, pc}
 80002d8:	40021000 	.word	0x40021000
 80002dc:	40010000 	.word	0x40010000
 80002e0:	40010400 	.word	0x40010400

080002e4 <init_timer>:

// Initialize the timer for LED speed control
// TIM2 for blinking
// The TIM2 interrupt is used to toggle the LEDs on a timed schedule, essentially making them "blink" or change pattern automatically in the background, without needing to wait/block in the main loop.
void init_timer() {
 80002e4:	b580      	push	{r7, lr}
 80002e6:	af00      	add	r7, sp, #0
    RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;  	// Enable TIM2 clock
 80002e8:	4b12      	ldr	r3, [pc, #72]	@ (8000334 <init_timer+0x50>)
 80002ea:	69db      	ldr	r3, [r3, #28]
 80002ec:	4a11      	ldr	r2, [pc, #68]	@ (8000334 <init_timer+0x50>)
 80002ee:	f043 0301 	orr.w	r3, r3, #1
 80002f2:	61d3      	str	r3, [r2, #28]
    TIM2->PSC = 4000;  						// Prescaler value (8 MHz / 8000 = 1 kHz)
 80002f4:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 80002f8:	f44f 627a 	mov.w	r2, #4000	@ 0xfa0
 80002fc:	629a      	str	r2, [r3, #40]	@ 0x28
    TIM2->ARR = 1000;  						// Auto-reload value for 1 Hz blinking
 80002fe:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8000302:	f44f 727a 	mov.w	r2, #1000	@ 0x3e8
 8000306:	62da      	str	r2, [r3, #44]	@ 0x2c
    TIM2->DIER |= TIM_DIER_UIE;  			// Enable update interrupt
 8000308:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 800030c:	68db      	ldr	r3, [r3, #12]
 800030e:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
 8000312:	f043 0301 	orr.w	r3, r3, #1
 8000316:	60d3      	str	r3, [r2, #12]
    TIM2->CR1 |= TIM_CR1_CEN;  				// Start the timer
 8000318:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 800031c:	681b      	ldr	r3, [r3, #0]
 800031e:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
 8000322:	f043 0301 	orr.w	r3, r3, #1
 8000326:	6013      	str	r3, [r2, #0]
    NVIC_EnableIRQ(TIM2_IRQn);  			// Enable TIM2 interrupt in NVIC
 8000328:	201c      	movs	r0, #28
 800032a:	f7ff ff53 	bl	80001d4 <__NVIC_EnableIRQ>
    // Nested Vectored Interrupt Controller (NVIC) to enable the interrupt line for Timer 2 (TIM2).
    // Once enabled, if TIM2 triggers an interrupt (like a timer overflow), the corresponding interrupt handler (TIM2_IRQHandler()) will be called automatically by the CPU.
}
 800032e:	bf00      	nop
 8000330:	bd80      	pop	{r7, pc}
 8000332:	bf00      	nop
 8000334:	40021000 	.word	0x40021000

08000338 <TIM2_IRQHandler>:

// Actual timer interrupt handler for controlling LED speed
void TIM2_IRQHandler(void) {
 8000338:	b580      	push	{r7, lr}
 800033a:	af00      	add	r7, sp, #0
    if (TIM2->SR & TIM_SR_UIF) {  // Check update interrupt flag, TIM_SR_UIF is the "update interrupt flag" — it tells us the timer overflowed.
 800033c:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8000340:	691b      	ldr	r3, [r3, #16]
 8000342:	f003 0301 	and.w	r3, r3, #1
 8000346:	2b00      	cmp	r3, #0
 8000348:	d009      	beq.n	800035e <TIM2_IRQHandler+0x26>
        TIM2->SR &= ~TIM_SR_UIF;  // Manually clear interrupt flag
 800034a:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 800034e:	691b      	ldr	r3, [r3, #16]
 8000350:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
 8000354:	f023 0301 	bic.w	r3, r3, #1
 8000358:	6113      	str	r3, [r2, #16]
        toggle_leds();			  // Change LED pattern
 800035a:	f000 f86d 	bl	8000438 <toggle_leds>
    }
}
 800035e:	bf00      	nop
 8000360:	bd80      	pop	{r7, pc}
	...

08000364 <get_led_state>:

// Returns the current LED state- allows other parts of the program to retrieve the LED state without directly accessing the led_state variable.
uint8_t get_led_state() {
 8000364:	b480      	push	{r7}
 8000366:	af00      	add	r7, sp, #0
    return led_state;
 8000368:	4b03      	ldr	r3, [pc, #12]	@ (8000378 <get_led_state+0x14>)
 800036a:	781b      	ldrb	r3, [r3, #0]
}
 800036c:	4618      	mov	r0, r3
 800036e:	46bd      	mov	sp, r7
 8000370:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000374:	4770      	bx	lr
 8000376:	bf00      	nop
 8000378:	2000001c 	.word	0x2000001c

0800037c <set_led_state>:

// Set the LED state with encapsulation
void set_led_state(uint8_t state) {
 800037c:	b480      	push	{r7}
 800037e:	b085      	sub	sp, #20
 8000380:	af00      	add	r7, sp, #0
 8000382:	4603      	mov	r3, r0
 8000384:	71fb      	strb	r3, [r7, #7]
    led_state = state;
 8000386:	4a07      	ldr	r2, [pc, #28]	@ (80003a4 <set_led_state+0x28>)
 8000388:	79fb      	ldrb	r3, [r7, #7]
 800038a:	7013      	strb	r3, [r2, #0]
    uint8_t *led_register = ((uint8_t*)&(GPIOE->ODR)) + 1; // updates led_state and writes it to GPIOE output register (specifically bits 8–15, hence the offset).
 800038c:	4b06      	ldr	r3, [pc, #24]	@ (80003a8 <set_led_state+0x2c>)
 800038e:	60fb      	str	r3, [r7, #12]
    // To control LEDs, need to write to bits 8-15 of ODR (output data register)
    // Note that it is only uint8_t here (compared to uint16_t above) because each LED (PE8-15) uses only 1 bit in the ODR register compared to 2 in the MODER register.
    *led_register = state;
 8000390:	68fb      	ldr	r3, [r7, #12]
 8000392:	79fa      	ldrb	r2, [r7, #7]
 8000394:	701a      	strb	r2, [r3, #0]
}
 8000396:	bf00      	nop
 8000398:	3714      	adds	r7, #20
 800039a:	46bd      	mov	sp, r7
 800039c:	f85d 7b04 	ldr.w	r7, [sp], #4
 80003a0:	4770      	bx	lr
 80003a2:	bf00      	nop
 80003a4:	2000001c 	.word	0x2000001c
 80003a8:	48001015 	.word	0x48001015

080003ac <set_button_callback>:


// Set the button press callback function, Allows registering a function to call when the button is pressed
// The function set_button_callback() allows the user to pass in a function pointer. This pointer is stored in the button_callback variable, so whenever the button is pressed, the corresponding function can be called.
void set_button_callback(void (*callback)()) { // *callback pointer
 80003ac:	b480      	push	{r7}
 80003ae:	b083      	sub	sp, #12
 80003b0:	af00      	add	r7, sp, #0
 80003b2:	6078      	str	r0, [r7, #4]
    button_callback = callback;
 80003b4:	4a04      	ldr	r2, [pc, #16]	@ (80003c8 <set_button_callback+0x1c>)
 80003b6:	687b      	ldr	r3, [r7, #4]
 80003b8:	6013      	str	r3, [r2, #0]
}
 80003ba:	bf00      	nop
 80003bc:	370c      	adds	r7, #12
 80003be:	46bd      	mov	sp, r7
 80003c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80003c4:	4770      	bx	lr
 80003c6:	bf00      	nop
 80003c8:	20000020 	.word	0x20000020

080003cc <EXTI0_IRQHandler>:

// Clears interrupt pending flag and runs the registered callback if it exists.
// Interrupt handler for button press (PA0)
// When the button (PA0) triggers an interrupt, the EXTI0_IRQHandler ISR is executed. Inside the ISR, the function pointer button_callback is checked, and if it is not NULL, the callback function is called. This triggers the function you passed during initialization.
void EXTI0_IRQHandler(void) {
 80003cc:	b580      	push	{r7, lr}
 80003ce:	af00      	add	r7, sp, #0
    if (EXTI->PR & EXTI_PR_PR0) {  			// Check if the interrupt is pending for Pa0 (button)
 80003d0:	4b0a      	ldr	r3, [pc, #40]	@ (80003fc <EXTI0_IRQHandler+0x30>)
 80003d2:	695b      	ldr	r3, [r3, #20]
 80003d4:	f003 0301 	and.w	r3, r3, #1
 80003d8:	2b00      	cmp	r3, #0
 80003da:	d00c      	beq.n	80003f6 <EXTI0_IRQHandler+0x2a>
        EXTI->PR |= EXTI_PR_PR0;  			// Clear interrupt flag
 80003dc:	4b07      	ldr	r3, [pc, #28]	@ (80003fc <EXTI0_IRQHandler+0x30>)
 80003de:	695b      	ldr	r3, [r3, #20]
 80003e0:	4a06      	ldr	r2, [pc, #24]	@ (80003fc <EXTI0_IRQHandler+0x30>)
 80003e2:	f043 0301 	orr.w	r3, r3, #1
 80003e6:	6153      	str	r3, [r2, #20]
        if (button_callback != NULL) {
 80003e8:	4b05      	ldr	r3, [pc, #20]	@ (8000400 <EXTI0_IRQHandler+0x34>)
 80003ea:	681b      	ldr	r3, [r3, #0]
 80003ec:	2b00      	cmp	r3, #0
 80003ee:	d002      	beq.n	80003f6 <EXTI0_IRQHandler+0x2a>
            button_callback();  			// Call the registered callback function
 80003f0:	4b03      	ldr	r3, [pc, #12]	@ (8000400 <EXTI0_IRQHandler+0x34>)
 80003f2:	681b      	ldr	r3, [r3, #0]
 80003f4:	4798      	blx	r3
        }
    }
}
 80003f6:	bf00      	nop
 80003f8:	bd80      	pop	{r7, pc}
 80003fa:	bf00      	nop
 80003fc:	40010400 	.word	0x40010400
 8000400:	20000020 	.word	0x20000020

08000404 <initialise_digital_io>:

void initialise_digital_io() {
 8000404:	b480      	push	{r7}
 8000406:	b083      	sub	sp, #12
 8000408:	af00      	add	r7, sp, #0
    // Configure PE8–PE15 as outputs (LEDs)
    uint16_t *led_output_registers = ((uint16_t *)&(GPIOE->MODER)) + 1;
 800040a:	4b0a      	ldr	r3, [pc, #40]	@ (8000434 <initialise_digital_io+0x30>)
 800040c:	607b      	str	r3, [r7, #4]
    *led_output_registers = 0x5555;
 800040e:	687b      	ldr	r3, [r7, #4]
 8000410:	f245 5255 	movw	r2, #21845	@ 0x5555
 8000414:	801a      	strh	r2, [r3, #0]

    // Configure PA0 (button) as input
    GPIOA->MODER &= ~(0x3 << (0 * 2));
 8000416:	f04f 4390 	mov.w	r3, #1207959552	@ 0x48000000
 800041a:	681b      	ldr	r3, [r3, #0]
 800041c:	f04f 4290 	mov.w	r2, #1207959552	@ 0x48000000
 8000420:	f023 0303 	bic.w	r3, r3, #3
 8000424:	6013      	str	r3, [r2, #0]
}
 8000426:	bf00      	nop
 8000428:	370c      	adds	r7, #12
 800042a:	46bd      	mov	sp, r7
 800042c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000430:	4770      	bx	lr
 8000432:	bf00      	nop
 8000434:	48001002 	.word	0x48001002

08000438 <toggle_leds>:
// LED toggle, button check, and wait functions
//Toggle: XOR current LED bits to toggle them.
// is_button_pressed: checks if PA0 is high.
// wait_for_button_press/release: blocking loops for button status.
// Toggle LEDs (PE8-15)
void toggle_leds() {
 8000438:	b580      	push	{r7, lr}
 800043a:	b082      	sub	sp, #8
 800043c:	af00      	add	r7, sp, #0
	 uint8_t *led_register = ((uint8_t*)&(GPIOE->ODR)) + 1;
 800043e:	4b08      	ldr	r3, [pc, #32]	@ (8000460 <toggle_leds+0x28>)
 8000440:	607b      	str	r3, [r7, #4]
	 *led_register ^= get_led_state();
 8000442:	f7ff ff8f 	bl	8000364 <get_led_state>
 8000446:	4603      	mov	r3, r0
 8000448:	461a      	mov	r2, r3
 800044a:	687b      	ldr	r3, [r7, #4]
 800044c:	781b      	ldrb	r3, [r3, #0]
 800044e:	4053      	eors	r3, r2
 8000450:	b2da      	uxtb	r2, r3
 8000452:	687b      	ldr	r3, [r7, #4]
 8000454:	701a      	strb	r2, [r3, #0]
}
 8000456:	bf00      	nop
 8000458:	3708      	adds	r7, #8
 800045a:	46bd      	mov	sp, r7
 800045c:	bd80      	pop	{r7, pc}
 800045e:	bf00      	nop
 8000460:	48001015 	.word	0x48001015

08000464 <chase_led_callback>:
}

// button callback for LED
// Rotates the LED pattern left.
// The MSB wraps around to LSB. Creates a "chasing" LED effect.
void chase_led_callback() {
 8000464:	b580      	push	{r7, lr}
 8000466:	b082      	sub	sp, #8
 8000468:	af00      	add	r7, sp, #0
    uint8_t state = get_led_state();
 800046a:	f7ff ff7b 	bl	8000364 <get_led_state>
 800046e:	4603      	mov	r3, r0
 8000470:	71fb      	strb	r3, [r7, #7]
    state = (state << 1) | ((state & 0x80) >> 7);  // Rotate left by wrapping leftmost bit to rightmost position
 8000472:	79fb      	ldrb	r3, [r7, #7]
 8000474:	005b      	lsls	r3, r3, #1
 8000476:	b25a      	sxtb	r2, r3
 8000478:	79fb      	ldrb	r3, [r7, #7]
 800047a:	09db      	lsrs	r3, r3, #7
 800047c:	b2db      	uxtb	r3, r3
 800047e:	b25b      	sxtb	r3, r3
 8000480:	4313      	orrs	r3, r2
 8000482:	b25b      	sxtb	r3, r3
 8000484:	71fb      	strb	r3, [r7, #7]
    set_led_state(state);
 8000486:	79fb      	ldrb	r3, [r7, #7]
 8000488:	4618      	mov	r0, r3
 800048a:	f7ff ff77 	bl	800037c <set_led_state>
}
 800048e:	bf00      	nop
 8000490:	3708      	adds	r7, #8
 8000492:	46bd      	mov	sp, r7
 8000494:	bd80      	pop	{r7, pc}
	...

08000498 <main>:

int main(void) {
 8000498:	b580      	push	{r7, lr}
 800049a:	af00      	add	r7, sp, #0
	// Initializes clocks, I/O, timer, and LED state.
	// Registers a callback to rotate LEDs when button is pressed.
	// Main loop is idle — interrupts handle everything.
    enable_clocks();
 800049c:	f7ff fee2 	bl	8000264 <enable_clocks>
    initialise_digital_io();  // Make sure to initialize GPIOs
 80004a0:	f7ff ffb0 	bl	8000404 <initialise_digital_io>
    init_timer();
 80004a4:	f7ff ff1e 	bl	80002e4 <init_timer>

    // Initialize LED state to a known pattern
    set_led_state(0b00000001);
 80004a8:	2001      	movs	r0, #1
 80004aa:	f7ff ff67 	bl	800037c <set_led_state>

    // Set the button callback to chase LEDs
    set_button_callback(chase_led_callback);
 80004ae:	4803      	ldr	r0, [pc, #12]	@ (80004bc <main+0x24>)
 80004b0:	f7ff ff7c 	bl	80003ac <set_button_callback>
    enable_interrupt();
 80004b4:	f7ff feec 	bl	8000290 <enable_interrupt>

    while (1) {
 80004b8:	bf00      	nop
 80004ba:	e7fd      	b.n	80004b8 <main+0x20>
 80004bc:	08000465 	.word	0x08000465

080004c0 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 80004c0:	480d      	ldr	r0, [pc, #52]	@ (80004f8 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 80004c2:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
 80004c4:	f3af 8000 	nop.w

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 80004c8:	480c      	ldr	r0, [pc, #48]	@ (80004fc <LoopForever+0x6>)
  ldr r1, =_edata
 80004ca:	490d      	ldr	r1, [pc, #52]	@ (8000500 <LoopForever+0xa>)
  ldr r2, =_sidata
 80004cc:	4a0d      	ldr	r2, [pc, #52]	@ (8000504 <LoopForever+0xe>)
  movs r3, #0
 80004ce:	2300      	movs	r3, #0
  b LoopCopyDataInit
 80004d0:	e002      	b.n	80004d8 <LoopCopyDataInit>

080004d2 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 80004d2:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 80004d4:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 80004d6:	3304      	adds	r3, #4

080004d8 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 80004d8:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 80004da:	428c      	cmp	r4, r1
  bcc CopyDataInit
 80004dc:	d3f9      	bcc.n	80004d2 <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
 80004de:	4a0a      	ldr	r2, [pc, #40]	@ (8000508 <LoopForever+0x12>)
  ldr r4, =_ebss
 80004e0:	4c0a      	ldr	r4, [pc, #40]	@ (800050c <LoopForever+0x16>)
  movs r3, #0
 80004e2:	2300      	movs	r3, #0
  b LoopFillZerobss
 80004e4:	e001      	b.n	80004ea <LoopFillZerobss>

080004e6 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 80004e6:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 80004e8:	3204      	adds	r2, #4

080004ea <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 80004ea:	42a2      	cmp	r2, r4
  bcc FillZerobss
 80004ec:	d3fb      	bcc.n	80004e6 <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
 80004ee:	f000 f811 	bl	8000514 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 80004f2:	f7ff ffd1 	bl	8000498 <main>

080004f6 <LoopForever>:

LoopForever:
  b LoopForever
 80004f6:	e7fe      	b.n	80004f6 <LoopForever>
  ldr   r0, =_estack
 80004f8:	2000a000 	.word	0x2000a000
  ldr r0, =_sdata
 80004fc:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8000500:	20000000 	.word	0x20000000
  ldr r2, =_sidata
 8000504:	0800057c 	.word	0x0800057c
  ldr r2, =_sbss
 8000508:	20000000 	.word	0x20000000
  ldr r4, =_ebss
 800050c:	20000024 	.word	0x20000024

08000510 <ADC1_2_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 8000510:	e7fe      	b.n	8000510 <ADC1_2_IRQHandler>
	...

08000514 <__libc_init_array>:
 8000514:	b570      	push	{r4, r5, r6, lr}
 8000516:	4d0d      	ldr	r5, [pc, #52]	@ (800054c <__libc_init_array+0x38>)
 8000518:	4c0d      	ldr	r4, [pc, #52]	@ (8000550 <__libc_init_array+0x3c>)
 800051a:	1b64      	subs	r4, r4, r5
 800051c:	10a4      	asrs	r4, r4, #2
 800051e:	2600      	movs	r6, #0
 8000520:	42a6      	cmp	r6, r4
 8000522:	d109      	bne.n	8000538 <__libc_init_array+0x24>
 8000524:	4d0b      	ldr	r5, [pc, #44]	@ (8000554 <__libc_init_array+0x40>)
 8000526:	4c0c      	ldr	r4, [pc, #48]	@ (8000558 <__libc_init_array+0x44>)
 8000528:	f000 f818 	bl	800055c <_init>
 800052c:	1b64      	subs	r4, r4, r5
 800052e:	10a4      	asrs	r4, r4, #2
 8000530:	2600      	movs	r6, #0
 8000532:	42a6      	cmp	r6, r4
 8000534:	d105      	bne.n	8000542 <__libc_init_array+0x2e>
 8000536:	bd70      	pop	{r4, r5, r6, pc}
 8000538:	f855 3b04 	ldr.w	r3, [r5], #4
 800053c:	4798      	blx	r3
 800053e:	3601      	adds	r6, #1
 8000540:	e7ee      	b.n	8000520 <__libc_init_array+0xc>
 8000542:	f855 3b04 	ldr.w	r3, [r5], #4
 8000546:	4798      	blx	r3
 8000548:	3601      	adds	r6, #1
 800054a:	e7f2      	b.n	8000532 <__libc_init_array+0x1e>
 800054c:	08000574 	.word	0x08000574
 8000550:	08000574 	.word	0x08000574
 8000554:	08000574 	.word	0x08000574
 8000558:	08000578 	.word	0x08000578

0800055c <_init>:
 800055c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800055e:	bf00      	nop
 8000560:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8000562:	bc08      	pop	{r3}
 8000564:	469e      	mov	lr, r3
 8000566:	4770      	bx	lr

08000568 <_fini>:
 8000568:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800056a:	bf00      	nop
 800056c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800056e:	bc08      	pop	{r3}
 8000570:	469e      	mov	lr, r3
 8000572:	4770      	bx	lr
